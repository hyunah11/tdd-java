- UserPointTable 라는 저장소에서 ConcurrentHashMap, 원자 함수 compute로 원자 갱신을 하는 방법도 있지만 
UserPointTable 클래스는 변경하지 않는다는 제약 조건이 있습니다.
인 메모리 차원에서는 User 단위 락으로 임계영역을 보호하는 방법이 있습니다.
하지만 다른 User가 영향을 미치는 서비스가 존재한다면 다른 방법을 고려해야 합니다.

### 기존 코드 동시성 이슈
- 레이스 컨디션 문제: 읽고-수정-쓰기(read–modify–write) 패턴이기 때문에 다른 스레드가 끼어들면 결과가 덮어써지는 문제가 있습니다.
- pointHistoryTable.insert()와 userPointTable.insertOrUpdate()가 원자적으로 묶여있지 않습니다. 같은 임계영역이어야 합니다.
- 네트워크 재시도, 중복 클릭 등으로 동일 요청이 여러 번 들어오면 중복으로 충전/차감됩니다.

### 대안
- 전역 락은 전체 서비스 처리량이 더 낮아지므로 userId 단위 락 사용
- 멀티 인스턴스일 경우 DB 트랜잭션, 멱등성 키 설계 고려
- 블로킹 락을 쓰지 않고 userId별 CAS 연산과 Atomic 키워드 사용하는 방법이 있지만, CAS 충돌이 잦으면 좋은 대안이 아닙니다.